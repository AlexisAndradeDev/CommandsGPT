import functools
from typing import Any
import json

from . import commands_funcs
from .. import regex
from ..static import StaticVar
from ..config import Config

@functools.total_ordering
class CommandNode:
    def __init__(self, data):
        self.id = data[0]
        self.previous_command_id = data[1][0] if data[1] else None
        self.dependent_on_data = data[1][1] if data[1] else None
        self.required_value = data[1][2] if data[1] else None
        self.command_name = data[2]
        assert self.command_name in commands_funcs.COMMANDS, f"Command '{self.command_name}' does not exist."
        self.command = commands_funcs.get_command(self.command_name)
        self.arguments = data[3] if len(data) > 3 else None

    def __eq__(self, other):
        return self.id == other.id

    def __lt__(self, other):
        return self.id < other.id

    def __str__(self):
        return f"CommandNode(id={self.id}, previous_command_id={self.previous_command_id}, dependent_on_data={self.dependent_on_data}, required_value={self.required_value}, command={self.command})"

    def execute_command(self, config: Config, arguments: dict[str, Any]):
        print(f"\n\nRunning '{self.command_name}' command with id {self.id}...")
        self.data_generated = self.command(config, **arguments)

def build_dependency_graph(commands_data: list[list]) -> dict[str, CommandNode]:
    graph = {}
    for command_data in commands_data:
        node = CommandNode(command_data)
        graph[node.id] = node
    return graph

def execute_node(node: CommandNode, graph: dict[str, CommandNode], config: Config,
        generated_data: dict, data_references: dict[dict[int, Any]], raw_commands_data: StaticVar):
    if node.id in generated_data:
        # already executed
        return generated_data[node.id]

    if node.previous_command_id is not None:
        command_generated_data = execute_node(
            graph[node.previous_command_id], graph, config, generated_data, 
            data_references, raw_commands_data,
        )

        if node.dependent_on_data:
            if command_generated_data[node.dependent_on_data] != node.required_value:
                return None

    node.execute_command(config, node.arguments)
    generated_data[node.id] = node.data_generated

    if node.id in data_references:
        # inject data generated by the node to the data string
        raw_commands_data.val = regex.inject_node_data(raw_commands_data.val, node.id, generated_data[node.id])
        # inject data to graph
        commands_data = json.loads(raw_commands_data.val, strict=False)
        graph_ = build_dependency_graph(commands_data)
        for key in graph_:
            graph[key] = graph_[key]

    return node.data_generated

def print_commands_graph(graph: dict[str, CommandNode]):
    print("\n\n--- Commands graph ---")
    for node in graph.values():
        print(f"\n{node.id}. {node.command_name}")
        if node.previous_command_id:
            print(f"\n\tExecuted after node «{node.previous_command_id}».")
        if node.dependent_on_data:
            print(f"\n\t\tResult field '{node.dependent_on_data}' of node «{node.previous_command_id}» must have value «{node.required_value}» in order to execute this node.")
    print("\n--- -------------- ---\n")

def execute_commands(config: Config, graph: dict[str, CommandNode], graph_data: dict[str, Any]):
    print_commands_graph(graph)

    generated_data = {}
    for node_id in sorted(graph.keys()):
        node = graph[node_id]
        execute_node(
            node, graph, config, generated_data, graph_data["data_references"],
            graph_data["raw_commands_data"],
        )
