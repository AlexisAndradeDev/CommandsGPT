from typing import Any, Callable
from ..chat import get_answer_from_model
from ..config import Config

COMMANDS = {
    "THINK": {
        "description": "Generates a thought in your 'mind' without writing it down yet. This command allows you to create new ideas, reflect, and analyze information. For example, when asked to 'Write a three-paragraph article about Lenz's Law,' you would first use this command to generate the article and then use another to write it.",
        "arguments": {
            "about": {"description": "What to think about. Example: 'Three-paragraph article about Lenz's Law.'", "type": "string"},
        },
        "generates_data": {
            "thought": {"description": "Text generated by thinking.", "type": "string"},
        },
    },
    "WRITE_TO_USER": {
        "description": "Writes something to the interface to communicate with the user.",
        "arguments": {
            "content": {"description": "Content to write.", "type": "string"},
        },
        "generates_data": {},
    },
    "REQUEST_USER_INPUT": {
        "description": "Asks the user to input data through the interface.",
        "arguments": {
            "message": {"description": "Message displayed to the user related to the data that will be requested (example: 'Enter your age').", "type": "string"},
        },
        "generates_data": {
            "input": {"description": "Data entered by the user", "type": "string"},
        },
    },
    "IF": {
        "description": "Returns the Boolean value of a condition.",
        "arguments": {
            "condition": {"description": "Condition. Can be in natural language.", "type": "string"},
        },
        "generates_data": {
            "result": {"description": "Result of the condition: 0 or 1.", "type": "boolean"},
        },
    },
}

# Commands functions
# Must be named 'LowercaseCommandName_command'
# The first argument will always be the Config object
# The arguments must match the arguments from the COMMANDS dictionary
# The return value must be a dictionary which keys must match the "generates_data" keys
# The data types must match the ones declared in the COMMANDS dictionary

def think_command(config: Config, about: str) -> dict[str, Any]:
    messages = [
        {
            "role": "system", 
            "content": "You are a model used when executing a 'THINK' command, which function is to reflect, think, write, or ideate."
        },
    ]
    thought = get_answer_from_model(about, config.chat_model, messages)

    results = {
        "thought": thought,
    }
    return results

def write_to_user_command(config: Config, content: str) -> dict[str, Any]:
    # add newlines because regex data injection replaces newline characters
    # by \\n substrings.
    content_with_newlines = "\n".join(content.split("\\n"))
    print(f">>> {content_with_newlines}")
    return {}

def request_user_input_command(config: Config, message: str) -> dict[str, Any]:
    input_ = input(f"{message}\n*: ")
    results = {
        "input": input_,
    }
    return results

def if_command(config: Config, condition: str) -> dict[str, Any]:
    messages = [
        {
            "role": "system", 
            "content": f"You are a model that evaluates conditions, both in natural language and symbolic language. Given a condition, you respond with the number «1» (true) or «0» (false). DO NOT write ANYTHING ELSE EVER.",
        },
    ]
    result = get_answer_from_model(condition, config.chat_model, messages)
    try:
        result = bool(result)
    except Exception as e:
        print(f"Could not convert result from IF command '{result}' to boolean.")
        raise e

    results = {
        "result": result,
    }
    return results

COMMAND_NAME_TO_COMMAND_FUNC = {
    key: eval(f"{key.lower()}_command")
    for key in COMMANDS
}

def get_command(command_name: str) -> Callable:
    """
    Returns the function corresponding to the name.

    Args:
        command_name (str): Name of the function.

    Returns:
        function: The corresponding function.
    """    
    return COMMAND_NAME_TO_COMMAND_FUNC[command_name]
