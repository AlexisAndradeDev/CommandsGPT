import functools
import json
from typing import Any, Callable

from . import commands_funcs
from .. import regex
from ..static import StaticVar
from ..config import Config

@functools.total_ordering
class CommandNode:
    def __init__(self, data: list, commands: dict[str, dict], command_name_to_func: dict[str, Callable]):
        self.id = data[0]
        self.previous_command_id = data[1][0] if data[1] else None
        self.dependent_on_data = data[1][1] if data[1] else None
        self.required_value = data[1][2] if data[1] else None
        self.command_name = data[2]

        assert self.command_name in commands, f"Command '{self.command_name}' does not exist."
        assert self.command_name in command_name_to_func, f"Command '{self.command_name}' does not have a function declaration."

        self.command = command_name_to_func[self.command_name]
        self.arguments = data[3] if len(data) > 3 else None

    def __eq__(self, other):
        return self.id == other.id

    def __lt__(self, other):
        return self.id < other.id

    def __str__(self):
        return f"CommandNode(id={self.id}, previous_command_id={self.previous_command_id}, dependent_on_data={self.dependent_on_data}, required_value={self.required_value}, command={self.command})"

    def execute_command(self, config: Config, arguments: dict[str, Any]):
        print(f"\n\nRunning '{self.command_name}' command with id {self.id}...")
        self.data_generated = self.command(config, **arguments)

def build_dependency_graph(commands_data: list[list], commands: dict[str, dict], command_name_to_func: dict[str, Callable]) -> dict[str, CommandNode]:
    graph = {}
    for command_data in commands_data:
        node = CommandNode(command_data, commands, command_name_to_func)
        graph[node.id] = node
    return graph

def execute_node(node: CommandNode, graph: dict[str, CommandNode], config: Config,
        generated_data: dict, data_references: dict[dict[int, Any]], raw_commands_data: StaticVar,
        commands: dict[str, dict], command_name_to_func: dict[str, Callable]):
    if node.id in generated_data:
        # already executed
        return generated_data[node.id]

    if node.previous_command_id is not None:
        command_generated_data = execute_node(
            graph[node.previous_command_id], graph, config, generated_data, 
            data_references, raw_commands_data, commands, command_name_to_func,
        )

        if node.dependent_on_data:
            if command_generated_data[node.dependent_on_data] != node.required_value:
                return None

    node.execute_command(config, node.arguments)
    generated_data[node.id] = node.data_generated

    if node.id in data_references:
        # inject data generated by the node to the data string
        raw_commands_data.val = regex.inject_node_data(raw_commands_data.val, node.id, generated_data[node.id])
        # inject data to graph
        # TODO: Fix JSON parsing error that is sometimes raised when newline characters are written.
        try:
            commands_data = json.loads(raw_commands_data.val, strict=False)
        except Exception as e:
            print(f"!!! Raw commands data: {raw_commands_data}")
            raise e
        graph_ = build_dependency_graph(commands_data, commands, command_name_to_func)
        for key in graph_:
            graph[key] = graph_[key]

    return node.data_generated

def print_commands_graph(graph: dict[str, CommandNode]):
    print("\n\n--- Commands graph ---")
    for node in graph.values():
        print(f"\n{node.id}. {node.command_name}")
        if node.previous_command_id:
            print(f"\n\tExecuted after node «{node.previous_command_id}».")
        if node.dependent_on_data:
            print(f"\n\t\tResult field '{node.dependent_on_data}' of node «{node.previous_command_id}» must have value «{node.required_value}» in order to execute this node.")
    print("\n--- -------------- ---\n")

def execute_commands(config: Config, graph: dict[str, CommandNode], 
        graph_data: dict[str, Any], commands: dict[str, dict], 
        command_name_to_func: dict[str, Callable]):
    print_commands_graph(graph)

    generated_data = {}
    for node_id in sorted(graph.keys()):
        node = graph[node_id]
        execute_node(
            node, graph, config, generated_data, graph_data["data_references"],
            graph_data["raw_commands_data"], commands, command_name_to_func,
        )
